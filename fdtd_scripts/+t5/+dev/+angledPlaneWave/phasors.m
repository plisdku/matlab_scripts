function [E, H, freqs] = phasors(direction, polarization, sourceSamples,...
    dielectricEpsilon, posE, posH, varargin)
% phasors  Obtain frequency-domain electromagnetic fields in illuminated
% multilayer structure at desired points
%
% Example: make an in-plane polarized wave propagating in the XY plane with
% a sinusoidal profile, for a halfspace problem (boundary between two
% permittivities) where the interface is normal to Y.
%
%   [E, H, freqs] = phasors([cos(theta) sin(theta) 0], [-sin(theta) cos(theta) 0], ...
%       sin(1:numTimesteps), [epsilonBottom epsilonTop], 
%       [0 0 0], [0 0 0]);
%
% or alternatively
%
%   [E, H, freqs] = phasors([cos(theta) sin(theta) 0], 'TM', sin(1:numTimesteps), ...
%       [epsilonBottom epsilonTop], [0 0 0], [0 0 0]);
%
% will provide the E and H phasors at point [0 0 0].
%
% freqs is the array of frequencies at which E and H are calculated.  It is
% determined automatically to range from 0 up past the bandwidth of the source
% wave.
%
% E and H are cell arrays containing {Ex, Ey, Ez} and {Hx, Hy, Hz} evaluated
% at all points in posE and posH.  For each point represented in Ex...Hz, 
% there are numel(freqs) complex amplitudes.
%
% The "normal" direction of the stack is determined in the tfsf_req file
% generated by Trogdor.
%
% direction is the propagation direction of the wave on the "bottom" of the
% stack (if dot(direction, normal) > 0) or the propagation direction of the
% wave on the "top" of the stack (if dot(direction, normal) < 0).
%
% polarization is the direction of E-field polarization in the incident
% wave.  This vector needs to be perpendicular to the direction
% vector.  Alternatively it can be specified with the string 'TE'
% or 'TM'. Here, 'TE' means the E field is perpendicular to the plane of 
% incidence, and 'TM' means the E field is parallel to the plane of incidence.
%
% sourceSamples gives the amplitude of the E field in the polarization
% direction on each timestep.
%
% dielectricEpsilon is an array of permittivities, one for each layer of
% the multilayer stack, starting at the bottom.  The bottom is the lowest
% layer with respect to the direction normal to the stack, e.g. lowest X
% for a stack symmetrical in the Y and Z directions.
%
% The permeability in each layer is assumed to be 1.

import t5.dev.angledPlaneWave.*

direction = reshape(direction, 1, []);

tfsfreq_0;

%% cutoff stuff
if numel(varargin) == 1
    cutoffFrequency = varargin{1};
end

%% Coordinate transformations
% This handles the different directions that the plane wave can be incident from.
% The multilayer solver for FDTD assumes a 1D z-directed space.
% After using the solver we rotate the fields back into the right direction.

if ~iscell(posE)
    posE_userCoords = {posE posE posE};
else
    posE_userCoords = posE;
end

if ~iscell(posH)
    posH_userCoords = {posH posH posH};
else
    posH_userCoords = posH;
end

[ijk, ijkInv] = multilayerCoordinatePermutation(afp, direction);

posE = cell(3,1);
posH = cell(3,1);
for xyz = 1:3
    posE{xyz} = posE_userCoords{ijk(xyz)}(:,ijk);
    posH{xyz} = posH_userCoords{ijk(xyz)}(:,ijk);
end


unitVec = [0 0 1];
layerNormal = unitVec(ijkInv);
%fprintf('Layer normal %i %i %i\n', layerNormal(1), layerNormal(2), layerNormal(3));

if ischar(polarization)
    polStr = polarization;
    if strcmpi(polarization, 'TE')
        polarization = cross(direction, layerNormal);
    elseif strcmpi(polarization, 'TM')
        polarization = cross(cross(direction, layerNormal), direction);
    else
        error('Unknown polarization %s', polarization);
    end
    
    if norm(polarization) == 0
        error(['Polarization undefined at normal incidence, please '...
            'specify as a vector instead of using TM or TE']);
    end
    
    fprintf('Interpreting %s polarization as E parallel to [%f %f %f]\n',...
        polStr, polarization);
end

polarization = polarization/norm(polarization);
direction = direction/norm(direction);

dxyz = afp.dxyz(ijk);
dt = afp.dt;
dz = dxyz(3);

srcDirection = direction(ijk);
srcPolarization = polarization(ijk);
srcOrigin = [0 0 0];


for xyz = 1:3
    if srcDirection(xyz) > 0
        srcOrigin(xyz) = afp.sampleBounds(xyz) - 5*dxyz(xyz); %(min(posE{1}(:,xyz)) - 5*dxyz(xyz));
    elseif srcDirection(xyz) < 0
        srcOrigin(xyz) = afp.sampleBounds(xyz+3) + 5*dxyz(xyz); %(max(posE{1}(:,xyz)) + 5*dxyz(xyz));
    else
        srcOrigin(xyz) = 0;
    end
end

%% Boundaries between materials
% For the halfspace system we just have two layers (so one boundary between them).

numSampleCells = afp.sampleHalfCells(4:6) - afp.sampleHalfCells(1:3) + 1;

boundaryHalfCells = find(diff(afp.grid));
boundaryHalfCells = boundaryHalfCells(2:end-1) - 1;

% Details: FDTD boundaries come in two flavors.
% If boundaryHalfCells(n) is even, then it represents an E-H boundary.
% If boundaryHalfCells(n) is odd, then it represents an H-E boundary.

firstHalfCell = afp.sampleHalfCells(ijk(3));
ehHalfCells = boundaryHalfCells(mod(boundaryHalfCells + firstHalfCell,2) == 0);
heHalfCells = setdiff(boundaryHalfCells, ehHalfCells);

firstSampleZ = afp.sampleBounds(ijk(3));
boundariesE = dz*[ehHalfCells/2 (heHalfCells+1)/2] + firstSampleZ;
boundariesH = dz*[(ehHalfCells+1)/2 heHalfCells/2] + firstSampleZ;

%% Multilayer solver!

% These are functions of z = exp(i*freq*dt), not just constant values!
% To modify the script for more layers, add more permittivities and permeabilities
% here!
epsilonDispersion = cell(numel(dielectricEpsilon, 1));
muDispersion = epsilonDispersion;

if iscell(dielectricEpsilon)
    epsilonDispersion = dielectricEpsilon;
    for layer = 1:numel(dielectricEpsilon)
        muDispersion{layer} = Constitutives.permeability(1);
    end
else
    for layer = 1:numel(dielectricEpsilon)
        epsilonDispersion{layer} = Constitutives.dielectric(dielectricEpsilon(layer));
        muDispersion{layer} = Constitutives.permeability(1);
    end
end

solver = AFPMultilayer(dxyz, dt, boundariesE, boundariesH, ...
    epsilonDispersion, muDispersion);
%%
solver.addSource(srcOrigin, srcDirection, srcPolarization, sourceSamples);

[srcSpectrum, freqs] = t5.analysis.spectrum(sourceSamples, 'Dt', dt);
cutoffIndex = bandwidth(srcSpectrum(1:round(length(srcSpectrum)/2)), -80);

if ~exist('cutoffFrequency', 'var')
    cutoffFrequency = freqs(cutoffIndex);
end

fprintf('Cutoff below %2.2f nm\n', 2e9*pi*3e8/cutoffFrequency);

%% Get the fields and estimate the leakage

[E H] = solver.solve(posE, posH, cutoffFrequency);
freqs = freqs(freqs < cutoffFrequency);

for xyz = 1:3
    if any(isnan(E{xyz}(:)))
        error('Solver produced NaN in E%s', char('w'+xyz));
    end
    if any(isinf(E{xyz}(:)))
        error('Solver produced infs in E%s', char('w'+xyz));
    end
    if any(isnan(H{xyz}(:)))
        error('Solver produced NaN in H%s', char('w'+xyz));
    end
    if any(isinf(H{xyz}(:)))
        error('Solver produced infs in H%s', char('w'+xyz));
    end
end

%keyboard
%% Unpermute into user coordinates again

[E{1:3}] = deal(E{ijkInv});
[H{1:3}] = deal(H{ijkInv});




