function generate(direction, polarization, sourceSamples, dielectricEpsilon)
%% generate  Create angled source plane wave file for multilayer stack.
% Usage: angledPlaneWave.generate(direction, polarization,
%   sourceSamples, dielectricEpsilon);
%
% Example: make an in-plane polarized wave propagating in the XY plane with
% a sinusoidal profile, for a halfspace problem (boundary between two
% permittivities) where the interface is normal to Y.
%
%   generate([cos(theta) sin(theta) 0], [-sin(theta) cos(theta) 0], ...
%       sin(1:numTimesteps), [epsilonBottom epsilonTop]);
%
% or alternatively
%
%   generate([cos(theta) sin(theta) 0], 'TM', sin(1:numTimesteps), ...
%       [epsilonBottom epsilonTop]);
%
% The "normal" direction of the stack is determined in the tfsf_req file
% generated by Trogdor.
%
% direction is the propagation direction of the wave on the "bottom" of the
% stack (if dot(direction, normal) > 0) or the propagation direction of the
% wave on the "top" of the stack (if dot(direction, normal) < 0).
%
% polarization is the direction of E-field polarization in the incident
% wave.  This vector needs to be perpendicular to the direction
% vector.  Alternatively it can be specified with the string 'TE'
% or 'TM'. Here, 'TE' means the E field is perpendicular to the plane of 
% incidence, and 'TM' means the E field is parallel to the plane of incidence.
%
% sourceSamples gives the amplitude of the E field in the polarization
% direction on each timestep.
%
% dielectricEpsilon is an array of permittivities, one for each layer of
% the multilayer stack, starting at the bottom.  The bottom is the lowest
% layer with respect to the direction normal to the stack, e.g. lowest X
% for a stack symmetrical in the Y and Z directions.
%
% The permeability in each layer is assumed to be 1.

import t5.*
import t5.dev.angledPlaneWave.*

%% Load the source request information from Trogdor.
% tfsfreq_0 generates a struct called afp (for "analytical field propagation", the
% method used here) with all the locations in space and time at which we must
% provide E and H.
if ~exist('tfsfreq_0')
    error('Before calling generatePlaneWave, make sure Trogdor has generated tfsfreq_0.');
end
tfsfreq_0;

%%

[E_freq, H_freq, freqs] = phasors(direction, polarization, sourceSamples,...
    dielectricEpsilon, {afp.posEx, afp.posEy, afp.posEz}, ...
    {afp.posHx, afp.posHy, afp.posHz});

%%

% Inverse Fourier transform
% Actually since I use a negative time frequency convention (that is, my waves
% propagate as exp(i*(k*x - w*t))) I use fft() here to calculate the time-reversed
% inverse Fourier transform.

tic
E_time = cell(3,1);
H_time = cell(3,1);
for xyz = 1:3
    E_time{xyz} = 2*fft(E_freq{xyz},length(sourceSamples),2);
    H_time{xyz} = 2*fft(H_freq{xyz},length(sourceSamples),2);
    
    % subtract off the startup amplitude.  This is due to a faulty DC component
    % which comes from failing to solve the dispersion relation at zero
    % frequency.
    E_time{xyz} = E_time{xyz} - mean(E_time{xyz}(:,1));
    H_time{xyz} = H_time{xyz} - mean(H_time{xyz}(:,1));
    
    assert(~any(isnan(E_time{xyz}(:))));
    assert(~any(isnan(H_time{xyz}(:))));
    
    assert(size(E_time{xyz}, 2) == length(sourceSamples));
    assert(size(H_time{xyz}, 2) == length(sourceSamples));
end
ifftTime = toc;

fprintf('Time to calculate ifft to recover time-domain fields: %2.2f s\n', ...
    ifftTime);


%%
%{
figure(1111); clf
for tt = 1:10:afp.numT
    plot3(posE{1}(:,2), posE{1}(:,3), real(E{2}(:,tt)), 'o');
    title(sprintf('Frame %i', tt));
    pause(0.1);
end
%}

%%

%figure(10);
%clf
%plot(real(H{1}(end,:)))


%% Write to file

fh = fopen(afp.inputFile, 'w');

for tt = 1:afp.numT
    
    for xyz = 1:3
        fwrite(fh,H_time{xyz}(:,tt),'float32');
    end
    
    for xyz = 1:3
        fwrite(fh,E_time{xyz}(:,tt),'float32');
    end
end

fclose(fh);

%% Measure the startup transients
maxSignal = max(abs(sourceSamples));
maxLeakyE = [0 0 0];
maxLeakyH = [0 0 0];

for xyz = 1:3
    maxLeakyE(xyz) = max(abs(real(E_time{xyz}(:,1))));
    maxLeakyH(xyz) = max(abs(real(H_time{xyz}(:,1))));
end

fprintf('Expected leakage fraction %2.4f\n', max(maxLeakyE)/maxSignal);



